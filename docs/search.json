[{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"the-flat-file-reality","dir":"Articles","previous_headings":"","what":"The Flat-File Reality","title":"Design Philosophy","text":"data analysis doesn’t happen databases. happens : - CSV exports business systems Excel files collaborators Periodic data dumps schema Multiple versions “” file world, ’s enforced uniqueness constraint, foreign key validation, schema migration. constraints exist head—scattered comments nobody reads. assumptions break, discover downstream: wrong row counts join, duplicated records report, model suddenly performs differently. , damage done.","code":"# customer_id should be unique... I think? # email shouldn't have NAs... right? customers <- read.csv(\"customers_march_v3_FINAL.csv\")"},{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"detection-not-enforcement","dir":"Articles","previous_headings":"","what":"Detection, Not Enforcement","title":"Design Philosophy","text":"keyed takes pragmatic approach: detect problems early, don’t try prevent absolutely. differs database thinking: enforce constraints? flat-file workflows: Data arrives pre-corrupted — can’t reject export already received Transformations happen outside control — Upstream systems change without notice R’s copy semantics lose attributes — Metadata can vanish unexpectedly Session boundaries reset state — persistent enforcement possible Rather fighting reality, keyed accepts . goal catching problems can still fix —import, joins, validation—preventing problems already inevitable.","code":""},{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"boundary-checks","dir":"Articles","previous_headings":"","what":"Boundary Checks","title":"Design Philosophy","text":"Checks run meaningful moments, continuously: keeps package lightweight. opt validation matters:","code":"df <- data.frame(id = 1:3, value = c(\"a\", \"b\", \"c\"))  # Check happens HERE - at key definition df <- key(df, id)  # No check here - just a filter df_filtered <- df |> filter(id > 1)  # No check here - just adding a column df_enriched <- df |> mutate(upper = toupper(value))  # Check happens HERE - at explicit assertion df |> lock_no_na(value)"},{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"strict-enforcement","dir":"Articles","previous_headings":"","what":"Strict Enforcement","title":"Design Philosophy","text":"operations break key assumptions, keyed errors requires explicit acknowledgment: proceed, use unkey() explicitly acknowledge ’re breaking key: error instead warn? Silent key removal dangerous — might notice warning Explicit better implicit — want break key, say Catches mistakes early — corrupt downstream analysis","code":"df <- data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")) |>   key(id)  # This would create duplicate ids - keyed stops you df |> mutate(id = 1) #> Error in `mutate()`: #> ! Key is no longer unique after transformation. #> ℹ Use `unkey()` first if you intend to break uniqueness. df |> unkey() |> mutate(id = 1) #> # A tibble: 3 × 2 #>      id x     #>   <dbl> <chr> #> 1     1 a     #> 2     1 b     #> 3     1 c"},{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"what-keyed-doesnt-do","dir":"Articles","previous_headings":"","what":"What keyed Doesn’t Do","title":"Design Philosophy","text":"deliberate non-goals: require infrastructure contradicts flat-file context. keyed stays minimal design.","code":""},{"path":"https://gillescolling.com/keyed/articles/philosophy.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Design Philosophy","text":"keyed helps : Define keys explicitly — key(df, col1, col2) Check assumptions boundaries — lock_unique(), lock_no_na() Diagnose joins problems occur — diagnose_join() Track row identity — add_id(), compare_ids() Detect drift versions — stamp(), check_drift() package warns assumptions break. doesn’t enforce correctness absolutely. constraint intentional—keeps keyed appropriate messy, schema-free world data analysis actually happens.","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"the-problem-silent-data-corruption","dir":"Articles","previous_headings":"","what":"The Problem: Silent Data Corruption","title":"Quick Start","text":"receive monthly customer exports CRM system. data unique customer_id values complete email addresses. One month, someone upstream changes export logic. Now customer_id duplicates emails missing. Without explicit checks, won’t notice something breaks downstream—wrong row counts join, duplicated invoices, failed email campaigns. February data looks fine glance: silently corrupt analysis.","code":"# January export: clean data january <- data.frame(   customer_id = c(101, 102, 103, 104, 105),   email = c(\"alice@example.com\", \"bob@example.com\", \"carol@example.com\",             \"dave@example.com\", \"eve@example.com\"),   segment = c(\"premium\", \"basic\", \"premium\", \"basic\", \"premium\") )  # February export: corrupted upstream (duplicates + missing email) february <- data.frame(   customer_id = c(101, 102, 102, 104, 105),  # Note: 102 is duplicated    email = c(\"alice@example.com\", \"bob@example.com\", NA,             \"dave@example.com\", \"eve@example.com\"),   segment = c(\"premium\", \"basic\", \"basic\", \"basic\", \"premium\") ) head(february) #>   customer_id             email segment #> 1         101 alice@example.com premium #> 2         102   bob@example.com   basic #> 3         102              <NA>   basic #> 4         104  dave@example.com   basic #> 5         105   eve@example.com premium nrow(february)  # Same row count #> [1] 5"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"the-solution-make-assumptions-explicit","dir":"Articles","previous_headings":"","what":"The Solution: Make Assumptions Explicit","title":"Quick Start","text":"keyed catches issues making assumptions explicit: Now try February’s corrupted data: error catches problem import time, downstream ’re debugging mysterious row count mismatch.","code":"# Define what you expect: customer_id is unique january_keyed <- january |>   key(customer_id) |>   lock_no_na(email)  # This works - January data is clean january_keyed #> # A keyed tibble: 5 x 3 #> # Key:            customer_id #>   customer_id email             segment #>         <dbl> <chr>             <chr>   #> 1         101 alice@example.com premium #> 2         102 bob@example.com   basic   #> 3         103 carol@example.com premium #> 4         104 dave@example.com  basic   #> 5         105 eve@example.com   premium # This fails immediately - duplicates detected february |>   key(customer_id) #> Warning: Key is not unique. #> ℹ 1 duplicate key value(s) found. #> ℹ Key columns: customer_id #> # A keyed tibble: 5 x 3 #> # Key:            customer_id #>   customer_id email             segment #>         <dbl> <chr>             <chr>   #> 1         101 alice@example.com premium #> 2         102 bob@example.com   basic   #> 3         102 NA                basic   #> 4         104 dave@example.com  basic   #> 5         105 eve@example.com   premium"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"workflow-1-monthly-data-validation","dir":"Articles","previous_headings":"","what":"Workflow 1: Monthly Data Validation","title":"Quick Start","text":"Goal: Validate month’s export expected constraints processing. Challenge: Data quality varies month--month. Silent corruption causes cascading errors. Strategy: Define keys assumptions , apply consistently import.","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"define-validation-function","dir":"Articles","previous_headings":"Workflow 1: Monthly Data Validation","what":"Define validation function","title":"Quick Start","text":"","code":"validate_customer_export <- function(df) {   df |>     key(customer_id) |>     lock_no_na(email) |>     lock_nrow(min = 1) }  # January: passes january_clean <- validate_customer_export(january) summary(january_clean) #>  #> ── Keyed Data Frame Summary #> Dimensions: 5 rows x 3 columns #>  #> Key columns: customer_id #> ✔ Key is unique #>  #> Row IDs: none"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"keys-survive-transformations","dir":"Articles","previous_headings":"Workflow 1: Monthly Data Validation","what":"Keys survive transformations","title":"Quick Start","text":"defined, keys persist dplyr operations:","code":"# Filter preserves key premium_customers <- january_clean |>   filter(segment == \"premium\")  has_key(premium_customers) #> [1] TRUE get_key_cols(premium_customers) #> [1] \"customer_id\"  # Mutate preserves key enriched <- january_clean |>   mutate(domain = sub(\".*@\", \"\", email))  has_key(enriched) #> [1] TRUE"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"strict-enforcement","dir":"Articles","previous_headings":"Workflow 1: Monthly Data Validation","what":"Strict enforcement","title":"Quick Start","text":"operation breaks uniqueness, keyed errors tells use unkey() first: proceed, must explicitly acknowledge breaking key:","code":"# This creates duplicates - keyed stops you january_clean |>   mutate(customer_id = 1) #> Error in `mutate()`: #> ! Key is no longer unique after transformation. #> ℹ Use `unkey()` first if you intend to break uniqueness. january_clean |>   unkey() |>   mutate(customer_id = 1) #> # A tibble: 5 × 3 #>   customer_id email             segment #>         <dbl> <chr>             <chr>   #> 1           1 alice@example.com premium #> 2           1 bob@example.com   basic   #> 3           1 carol@example.com premium #> 4           1 dave@example.com  basic   #> 5           1 eve@example.com   premium"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"workflow-2-safe-joins","dir":"Articles","previous_headings":"","what":"Workflow 2: Safe Joins","title":"Quick Start","text":"Goal: Join customer data orders without accidentally duplicating rows. Challenge: Join cardinality mistakes common hard debug. “one--one” join ’s actually one--many silently inflates data. Strategy: Use diagnose_join() understand cardinality joining.","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"create-sample-data","dir":"Articles","previous_headings":"Workflow 2: Safe Joins","what":"Create sample data","title":"Quick Start","text":"","code":"customers <- data.frame(   customer_id = 1:5,   name = c(\"Alice\", \"Bob\", \"Carol\", \"Dave\", \"Eve\"),   tier = c(\"gold\", \"silver\", \"gold\", \"bronze\", \"silver\") ) |>   key(customer_id)  orders <- data.frame(   order_id = 1:8,   customer_id = c(1, 1, 2, 3, 3, 3, 4, 5),   amount = c(100, 150, 200, 50, 75, 125, 300, 80) ) |>   key(order_id)"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"diagnose-before-joining","dir":"Articles","previous_headings":"Workflow 2: Safe Joins","what":"Diagnose before joining","title":"Quick Start","text":"diagnosis shows: Cardinality one--many: customer can multiple orders Coverage: Shows many keys match vs. don’t match Now know expect. left_join() create 8 rows (one per order), 5 (one per customer).","code":"diagnose_join(customers, orders, by = \"customer_id\", use_joinspy = FALSE) #>  #> ── Join Diagnosis #> Cardinality: one-to-many #> x: 5 rows, unique #> y: 8 rows, 3 duplicates"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"compare-key-structures","dir":"Articles","previous_headings":"Workflow 2: Safe Joins","what":"Compare key structures","title":"Quick Start","text":"shows join key exists tables different uniqueness properties—essential information joining.","code":"compare_keys(customers, orders) #>  #> ── Key Comparison #> Comparing on: customer_id #>  #> x: 5 unique keys #> y: 5 unique keys #>  #> Common: 5 (100.0% of x) #> Only in x: 0 #> Only in y: 0"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"workflow-3-row-identity-tracking","dir":"Articles","previous_headings":"","what":"Workflow 3: Row Identity Tracking","title":"Quick Start","text":"Goal: Track original rows survive complex pipeline. Challenge: filtering, aggregating, joining, lose track source rows contributed final data. Strategy: Use add_id() attach stable identifiers survive transformations.","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"add-row-ids","dir":"Articles","previous_headings":"Workflow 3: Row Identity Tracking","what":"Add row IDs","title":"Quick Start","text":"","code":"# Add UUIDs to rows customers_tracked <- customers |>   add_id()  customers_tracked #> # A keyed tibble: 5 x 4 #> # Key:            customer_id | .id #>   .id                                  customer_id name  tier   #>   <chr>                                      <int> <chr> <chr>  #> 1 c97e636d-cd69-4e0a-801c-862fbe6f1171           1 Alice gold   #> 2 0c4f2853-33fe-4e14-8bf7-f05b869df7ca           2 Bob   silver #> 3 bdaad0a7-57e6-433c-afc7-27820f3508fb           3 Carol gold   #> 4 74a24590-77bb-491f-a1a3-5fee028a6bc1           4 Dave  bronze #> 5 6c51e048-048d-45ef-b6fe-73be4351b115           5 Eve   silver"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"ids-survive-transformations","dir":"Articles","previous_headings":"Workflow 3: Row Identity Tracking","what":"IDs survive transformations","title":"Quick Start","text":"comparison shows exactly rows lost (filtered ) preserved.","code":"# Filter: IDs persist gold_customers <- customers_tracked |>   filter(tier == \"gold\")  get_id(gold_customers) #> [1] \"c97e636d-cd69-4e0a-801c-862fbe6f1171\" #> [2] \"bdaad0a7-57e6-433c-afc7-27820f3508fb\"  # Compare with original compare_ids(customers_tracked, gold_customers) #> $lost #> [1] \"0c4f2853-33fe-4e14-8bf7-f05b869df7ca\" #> [2] \"74a24590-77bb-491f-a1a3-5fee028a6bc1\" #> [3] \"6c51e048-048d-45ef-b6fe-73be4351b115\" #>  #> $gained #> character(0) #>  #> $preserved #> [1] \"c97e636d-cd69-4e0a-801c-862fbe6f1171\" #> [2] \"bdaad0a7-57e6-433c-afc7-27820f3508fb\""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"combining-data-with-id-handling","dir":"Articles","previous_headings":"Workflow 3: Row Identity Tracking","what":"Combining data with ID handling","title":"Quick Start","text":"appending new data, bind_id() handles ID conflicts:","code":"batch1 <- data.frame(x = 1:3) |> add_id() batch2 <- data.frame(x = 4:6)  # No IDs yet  # bind_id assigns new IDs to batch2 and checks for conflicts combined <- bind_id(batch1, batch2) combined #>                                    .id x #> 1 4f0617c9-643f-47a9-9a4c-456f9558fb8d 1 #> 2 4fb77981-65fc-42b6-9fad-79ad75a362f6 2 #> 3 a8e3e7d6-001b-4713-9886-129665db919f 3 #> 4 433c314e-5149-469f-b960-eb1c5b9b29b6 4 #> 5 fbe68c09-82d0-454b-a2e0-fe7f7ff68694 5 #> 6 f6776c3f-480a-4e3e-b94c-9170208e4edb 6"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"workflow-4-drift-detection","dir":"Articles","previous_headings":"","what":"Workflow 4: Drift Detection","title":"Quick Start","text":"Goal: Detect data changes unexpectedly pipeline runs. Challenge: Reference data (lookup tables, dimension tables) changes upstream without notice. pipeline silently uses stale assumptions. Strategy: Commit snapshots stamp() check drift check_drift().","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"commit-a-reference-snapshot","dir":"Articles","previous_headings":"Workflow 4: Drift Detection","what":"Commit a reference snapshot","title":"Quick Start","text":"","code":"# Commit current state as reference reference_data <- data.frame(   region_id = c(\"US\", \"EU\", \"APAC\"),   tax_rate = c(0.08, 0.20, 0.10) ) |>   key(region_id) |>   stamp() #> ✔ Snapshot committed: 76a76466..."},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"check-for-drift","dir":"Articles","previous_headings":"Workflow 4: Drift Detection","what":"Check for drift","title":"Quick Start","text":"","code":"# No changes yet check_drift(reference_data) #>  #> ── Drift Report #> Snapshot: 76a76466... (2026-02-25 11:16) #> ✔ No drift detected"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"detect-changes","dir":"Articles","previous_headings":"Workflow 4: Drift Detection","what":"Detect changes","title":"Quick Start","text":"drift report shows exactly changed, letting decide whether accept new data investigate.","code":"# Simulate upstream change: EU tax rate changed modified_data <- reference_data modified_data$tax_rate[2] <- 0.21  # Drift detected! check_drift(modified_data) #>  #> ── Drift Report #> Snapshot: 76a76466... (2026-02-25 11:16) #> ! Drift detected #>  #> ── Value Diff #> Key: region_id #>  #> ! Modified: 1 row(s) #> tax_rate: 1 change(s) #> Unchanged: 2 row(s)"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"row-level-diff","dir":"Articles","previous_headings":"Workflow 4: Drift Detection","what":"Row-level diff","title":"Quick Start","text":"detailed cell-level comparison, use diff() two keyed data frames:","code":"old_rates <- key(data.frame(   region_id = c(\"US\", \"EU\", \"APAC\"),   tax_rate  = c(0.08, 0.20, 0.10) ), region_id)  new_rates <- data.frame(   region_id = c(\"US\", \"EU\", \"APAC\", \"LATAM\"),   tax_rate  = c(0.08, 0.21, 0.10, 0.15) )  diff(old_rates, new_rates) #>  #> ── Value Diff #> Key: region_id #>  #> ℹ Added: 1 row(s) #> ! Modified: 1 row(s) #> tax_rate: 1 change(s) #> Unchanged: 2 row(s)"},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"cleanup","dir":"Articles","previous_headings":"Workflow 4: Drift Detection","what":"Cleanup","title":"Quick Start","text":"","code":"# Remove snapshots when done clear_all_snapshots() #> ! This will remove 1 snapshot(s) from cache. #> ✔ Cleared 1 snapshot(s)."},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"when-to-use-something-else","dir":"Articles","previous_headings":"","what":"When to Use Something Else","title":"Quick Start","text":"keyed designed flat-file workflows without database infrastructure. need: keyed fills specific gap: lightweight key tracking exploratory semi-structured workflows heavier tools add friction.","code":""},{"path":"https://gillescolling.com/keyed/articles/quickstart.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"Quick Start","text":"Design Philosophy - reasoning behind keyed’s approach Function Reference - Complete API documentation","code":""},{"path":"https://gillescolling.com/keyed/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gilles Colling. Author, maintainer, copyright holder.","code":""},{"path":"https://gillescolling.com/keyed/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Colling G (2026). keyed: Explicit Key Assumptions Flat-File Data. R package version 0.2.0, https://github.com/gcol33/keyed.","code":"@Manual{,   title = {keyed: Explicit Key Assumptions for Flat-File Data},   author = {Gilles Colling},   year = {2026},   note = {R package version 0.2.0},   url = {https://github.com/gcol33/keyed}, }"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"First , thank much taking time contribute keyed project! document provides guidelines contributing keyed—codebase documentation. guidelines meant guide , restrict . doubt, use best judgment feel free propose improvements issue pull request.","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table Of Contents","title":"Contribution Guidelines","text":"Code Conduct Obtaining source Setting R environment Installing source Testing Install dependencies Building documentation Design docs Project organization Contributing workflow Style guidelines Pull request checklist Reporting bugs","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contribution Guidelines","text":"project everyone participating governed Code Conduct (CODE_OF_CONDUCT.md). participating, expected uphold code maintain respectful, inclusive environment.","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Contribution Guidelines","text":"installation guide focused development. regular installation, please see README.","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"obtaining-the-source","dir":"","previous_headings":"Installation","what":"Obtaining the source","title":"Contribution Guidelines","text":"Clone keyed repository: work development branch:","code":"git clone https://github.com/gcol33/keyed.git cd keyed git checkout dev git pull origin dev"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"setting-up-your-r-environment","dir":"","previous_headings":"Installation","what":"Setting up your R environment","title":"Contribution Guidelines","text":"keyed pure R package compiled code. Install required tools R (≥ 4.1) Git editor IDE (RStudio, VS Code, etc.) Install development dependencies Load development build","code":"install.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"rmarkdown\", \"knitr\", \"pkgdown\")) devtools::load_all()"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"installing-from-source","dir":"","previous_headings":"Installation","what":"Installing from source","title":"Contribution Guidelines","text":"Build install package locally: Regenerate documentation :","code":"devtools::install() devtools::document()"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"Contribution Guidelines","text":"keyed uses testthat testing. tests located tests/testthat/. Run full test suite: Run complete package check: Run subset tests development: Guidelines: - Keep tests fast reproducible. - Use set.seed() random data. - Include edge cases expected failures. - Prefer small examples large datasets.","code":"devtools::test() devtools::check() testthat::test_dir(\"tests/testthat\") testthat::test_file(\"tests/testthat/test-key.R\")"},{"path":[]},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"install-dependencies","dir":"","previous_headings":"Documentation","what":"Install dependencies","title":"Contribution Guidelines","text":"","code":"install.packages(c(\"rmarkdown\", \"knitr\", \"pkgdown\"))"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"building-the-documentation","dir":"","previous_headings":"Documentation","what":"Building the documentation","title":"Contribution Guidelines","text":"Build vignettes: Build pkgdown site locally: generated site saved docs/ directory. Open docs/index.html browser view .","code":"devtools::build_vignettes() pkgdown::build_site()"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"design-of-the-docs","dir":"","previous_headings":"Documentation","what":"Design of the docs","title":"Contribution Guidelines","text":"Function documentation: man/ (generated roxygen2) Tutorials examples: vignettes/ Website configuration: _pkgdown.yml Package overview: README.md Changelog: NEWS.md","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"project-organization","dir":"","previous_headings":"","what":"Project organization","title":"Contribution Guidelines","text":"","code":"keyed/ ├── .github/                <- Continuous integration workflows ├── .gitignore ├── .Rbuildignore ├── keyed.Rproj ├── DESCRIPTION             <- Package metadata ├── NAMESPACE               <- Function exports and imports ├── LICENSE ├── LICENSE.md ├── NEWS.md ├── README.md ├── _pkgdown.yml ├── R/                      <- R source files ├── man/                    <- Generated documentation ├── vignettes/              <- Long-form documentation and usage examples ├── tests/ │   └── testthat/           <- Unit tests ├── docs/                   <- pkgdown website (generated) ├── doc/                    <- Built vignettes for local preview (ignored in Git) └── keyed.Rcheck/           <- Artifacts from local package checks (ignored)"},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"contributing-workflow","dir":"","previous_headings":"","what":"Contributing workflow","title":"Contribution Guidelines","text":"Create feature branch Make focused commits clear messages. Run tests checks committing: Update documentation roxygen2 NEWS.md. Update vignettes/examples user-facing behavior changes. Open pull request short description change. Respond review feedback constructively.","code":"git checkout -b feature/my-feature devtools::test() devtools::check()"},{"path":[]},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"r-code","dir":"","previous_headings":"Style guidelines","what":"R code","title":"Contribution Guidelines","text":"Use descriptive names consistent indentation. Prefer vectorized operations loops. Validate inputs early clear error messages. Document exported functions roxygen2.","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"tests","dir":"","previous_headings":"Style guidelines","what":"Tests","title":"Contribution Guidelines","text":"Add update tests functionality changes. Keep tests minimal reproducible. Avoid external dependencies unless essential.","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"pull-request-checklist","dir":"","previous_headings":"","what":"Pull request checklist","title":"Contribution Guidelines","text":"Tests pass (devtools::test() devtools::check()) Documentation updated (roxygen + NEWS.md) Vignettes/examples updated needed unrelated formatting changes PR description clearly explains change","code":""},{"path":"https://gillescolling.com/keyed/CONTRIBUTING.html","id":"reporting-bugs","dir":"","previous_headings":"","what":"Reporting bugs","title":"Contribution Guidelines","text":"reporting issue, please include: - minimal reproducible example (reprex) - Output sessionInfo() - Expected vs. actual results - R operating system version contributing keyed, agree code released license package.","code":""},{"path":"https://gillescolling.com/keyed/deprecated.html","id":null,"dir":"","previous_headings":"","what":"Deprecated Functions — Removal Timeline","title":"Deprecated Functions — Removal Timeline","text":"Current CRAN version: 0.1.3 Submitting CRAN: 0.2.0","code":""},{"path":"https://gillescolling.com/keyed/deprecated.html","id":"cran-policy","dir":"","previous_headings":"","what":"CRAN Policy","title":"Deprecated Functions — Removal Timeline","text":"CRAN explicit timeline removing deprecated functions. community convention least 6 months soft-deprecation removal, longer popular packages. hard rule : changes break reverse dependencies must coordinated CRAN maintainers advance. Since keyed currently zero reverse deps, removal discretion reasonable grace period. Sources: - CRAN Repository Policy - Posit Community discussion - R Packages (2e) — Lifecycle","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/keyed/deprecated.html","id":"commit_keyed--stamp","dir":"","previous_headings":"Timeline","what":"commit_keyed() → stamp()","title":"Deprecated Functions — Removal Timeline","text":"0.1.0–0.1.3 (CRAN): commit_keyed() snapshot function. 0.2.0 (internal): Soft-deprecated lifecycle::deprecate_warn(). Ships CRAN 0.2.0. Users see warning per session pointing stamp(). ~6 months 0.2.0 CRAN acceptance: Can escalate deprecate_stop() remove entirely. Current status: 0.2.0 yet CRAN. Update file actual CRAN acceptance date published, start countdown.","code":""},{"path":"https://gillescolling.com/keyed/deprecated.html","id":"removal-checklist","dir":"","previous_headings":"","what":"Removal Checklist","title":"Deprecated Functions — Removal Timeline","text":"removing deprecated function: Confirm soft-deprecated 6+ months CRAN Check reverse dependencies (revdepcheck::revdep_check()) Optionally escalate deprecate_stop() one release first Remove function R/ source Remove NAMESPACE (happens automatically via roxygen) Delete orphaned .Rd man page Update NEWS.md “Removed” entry Run R CMD check confirm clean removal","code":""},{"path":"https://gillescolling.com/keyed/index.html","id":"keyed","dir":"","previous_headings":"","what":"keyed: Explicit Key Assumptions for Flat-File Workflows","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Explicit Key Assumptions Flat-File Data keyed package brings database-style primary key protections R data frames. Declare columns must unique, keyed enforces constraint filters, joins, mutations. assumptions break, errors immediately instead failing silently downstream.","code":""},{"path":"https://gillescolling.com/keyed/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"","code":"library(keyed)  # Declare a primary key (errors if not unique) orders <- data.frame(   order_id = 1:4,   item     = c(\"apple\", \"bread\", \"apple\", \"cheese\"),   qty      = c(2, 1, 5, 3) ) orders <- key(orders, order_id)  # Key persists through dplyr orders |> dplyr::filter(qty > 1) |> has_key() #> [1] TRUE  # Watch for automatic drift detection orders <- orders |> watch() modified <- orders |> dplyr::mutate(qty = qty * 10) check_drift(modified) #> Drift detected #> Modified: 4 row(s) #>   qty: 4 change(s)"},{"path":"https://gillescolling.com/keyed/index.html","id":"statement-of-need","dir":"","previous_headings":"","what":"Statement of Need","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"databases, declare customer_id primary key engine enforces uniqueness. CSV Excel files, get guarantees. Duplicates slip silently, joins produce unexpected row counts, data assumptions implicit. Existing validation packages (pointblank, validate) offer comprehensive rule engines require upfront schema definitions. analysts working interactively flat files, overhead often high. result: assumptions go unchecked, errors surface far source. keyed addresses gap four lightweight mechanisms: four work directly data frames external dependencies, get key safety without leaving R.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/index.html","id":"keys","dir":"","previous_headings":"Features","what":"Keys","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Declare columns must unique. Keys persist base R dplyr operations, block transformation break uniqueness.","code":"# Single or composite keys customers <- key(customers, customer_id) sales     <- key(sales, region, year)  # Keys survive filtering active <- customers[customers$status == \"active\", ] has_key(active) #> [1] TRUE  # Uniqueness-breaking operations are blocked customers |> dplyr::mutate(customer_id = 1) #> Error: Key is no longer unique after transformation. #> i Use `unkey()` first if you intend to break uniqueness."},{"path":"https://gillescolling.com/keyed/index.html","id":"join-diagnostics","dir":"","previous_headings":"Features","what":"Join Diagnostics","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Preview join cardinality executing:","code":"diagnose_join(customers, orders, by = \"customer_id\") #> Cardinality: one-to-many #> customers: 1000 rows (unique) #> orders:    5432 rows (4432 duplicates) #> Left join will produce ~5432 rows"},{"path":"https://gillescolling.com/keyed/index.html","id":"locks","dir":"","previous_headings":"Features","what":"Locks","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Assert conditions pipeline checkpoints. Locks error immediately, never continuing silently. Available locks:","code":"customers |>   lock_unique(customer_id) |>   lock_no_na(email) |>   lock_nrow(min = 100)"},{"path":"https://gillescolling.com/keyed/index.html","id":"uuids","dir":"","previous_headings":"Features","what":"UUIDs","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Generate stable row identifiers data natural key. UUIDs survive transformations enable row-level tracking.","code":"customers <- add_id(customers)  # Track which rows were added or removed filtered <- customers |> dplyr::filter(name != \"Bob\") compare_ids(customers, filtered) #> Lost: 1 row (7b1e4a9c2f8d3601) #> Kept: 2 rows"},{"path":"https://gillescolling.com/keyed/index.html","id":"watch--diff","dir":"","previous_headings":"Features","what":"Watch & Diff","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"watch() turns drift detection manual ceremony automatic safety net. Watched data frames auto-snapshot dplyr verb, check_drift() always gives cell-level report last transformation changed. can also compare two keyed data frames directly diff(): Use unwatch() stop automatic stamping, clear_all_snapshots() free memory.","code":"df <- key(data.frame(id = 1:5, x = c(1, 2, 3, 4, 5)), id) |> watch()  # Every dplyr verb auto-snapshots before executing filtered <- df |> dplyr::filter(id <= 3) check_drift(filtered) #> Drift detected #> Removed: 2 row(s) #> Unchanged: 3 row(s)  # Each step in a chain tracks drift from the previous step result <- filtered |> dplyr::mutate(x = x * 100) check_drift(result) #> Drift detected #> Modified: 3 row(s) #>   x: 3 change(s) old <- key(data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")), id) new <- data.frame(id = 2:4, x = c(\"B\", \"c\", \"d\"))  diff(old, new) #> Key: id #> Removed: 1 row(s) #> Added: 1 row(s) #> Modified: 1 row(s) #>   x: 1 change(s) #> Unchanged: 1 row(s)"},{"path":"https://gillescolling.com/keyed/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"","code":"# Install from CRAN install.packages(\"keyed\")  # Or install development version from GitHub # install.packages(\"pak\") pak::pak(\"gcol33/keyed\")"},{"path":[]},{"path":"https://gillescolling.com/keyed/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"Quick Start Design Philosophy Function Reference","code":""},{"path":"https://gillescolling.com/keyed/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"“Software like sex: ’s better ’s free.” — Linus Torvalds ’m PhD student builds R packages free time believe good tools free open. started projects work figured others might find useful . package saved time, buying coffee nice way say thanks. helps coffee addiction.","code":""},{"path":"https://gillescolling.com/keyed/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"MIT (see LICENSE.md file)","code":""},{"path":"https://gillescolling.com/keyed/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"keyed: Explicit Key Assumptions for Flat-File Workflows","text":"","code":"@software{keyed,   author = {Colling, Gilles},   title = {keyed: Explicit Key Assumptions for Flat-File Data},   year = {2025},   url = {https://CRAN.R-project.org/package=keyed},   doi = {10.32614/CRAN.package.keyed} }"},{"path":"https://gillescolling.com/keyed/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Gilles Colling Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Add identity column — add_id","title":"Add identity column — add_id","text":"Adds stable UUID column row. opt-feature tracking row lineage transformations.","code":""},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add identity column — add_id","text":"","code":"add_id(.data, .id = \".id\", .overwrite = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add identity column — add_id","text":".data data frame. .id Column name ID (default: \".id\"). .overwrite TRUE, overwrite existing ID column. FALSE (default), error column exists.","code":""},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add identity column — add_id","text":"Data frame ID column added.","code":""},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add identity column — add_id","text":"IDs generated using hash row content plus random salt, making stable identical rows within session unique across different data frames. uuid package available, used true UUIDs. Otherwise, hash-based ID generated.","code":""},{"path":"https://gillescolling.com/keyed/reference/add_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add identity column — add_id","text":"","code":"df <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\")) df <- add_id(df) df"},{"path":"https://gillescolling.com/keyed/reference/assume_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that data is complete (no missing values anywhere) — assume_complete","title":"Assert that data is complete (no missing values anywhere) — assume_complete","text":"Checks columns NA values.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that data is complete (no missing values anywhere) — assume_complete","text":"","code":"assume_complete(.data, .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/assume_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that data is complete (no missing values anywhere) — assume_complete","text":".data data frame. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that data is complete (no missing values anywhere) — assume_complete","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert minimum coverage of values — assume_coverage","title":"Assert minimum coverage of values — assume_coverage","text":"Checks fraction non-NA values meets threshold. Useful joins verify expected coverage.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert minimum coverage of values — assume_coverage","text":"","code":"assume_coverage(.data, threshold, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/assume_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert minimum coverage of values — assume_coverage","text":".data data frame. threshold Minimum fraction non-NA values (0 1). ... Column names (unquoted) check. empty, checks columns. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert minimum coverage of values — assume_coverage","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert minimum coverage of values — assume_coverage","text":"","code":"df <- data.frame(id = 1:10, x = c(1:8, NA, NA)) assume_coverage(df, 0.8, x) assume_coverage(df, 0.9, x)  # warns (only 80% coverage)"},{"path":"https://gillescolling.com/keyed/reference/assume_no_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that columns have no missing values — assume_no_na","title":"Assert that columns have no missing values — assume_no_na","text":"Checks specified columns contain NA values.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_no_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that columns have no missing values — assume_no_na","text":"","code":"assume_no_na(.data, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/assume_no_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that columns have no missing values — assume_no_na","text":".data data frame. ... Column names (unquoted) check. empty, checks columns. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_no_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that columns have no missing values — assume_no_na","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_no_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert that columns have no missing values — assume_no_na","text":"","code":"df <- data.frame(id = 1:3, x = c(\"a\", NA, \"c\")) assume_no_na(df, id) assume_no_na(df, x)  # warns"},{"path":"https://gillescolling.com/keyed/reference/assume_nrow.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert row count within expected range — assume_nrow","title":"Assert row count within expected range — assume_nrow","text":"Checks number rows within expected range. Useful sanity checks filtering joins.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_nrow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert row count within expected range — assume_nrow","text":"","code":"assume_nrow(.data, min = 1, max = Inf, expected = NULL, .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/assume_nrow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert row count within expected range — assume_nrow","text":".data data frame. min Minimum expected rows (inclusive). Default 1. max Maximum expected rows (inclusive). Default Inf. expected Exact expected row count. provided, overrides min/max. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_nrow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert row count within expected range — assume_nrow","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_nrow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert row count within expected range — assume_nrow","text":"","code":"df <- data.frame(id = 1:100) assume_nrow(df, min = 50, max = 200) assume_nrow(df, expected = 100)"},{"path":"https://gillescolling.com/keyed/reference/assume_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that columns are unique — assume_unique","title":"Assert that columns are unique — assume_unique","text":"Checks combination specified columns unique values. point--time assertion either passes silently fails.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that columns are unique — assume_unique","text":"","code":"assume_unique(.data, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/assume_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that columns are unique — assume_unique","text":".data data frame. ... Column names (unquoted) check uniqueness. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that columns are unique — assume_unique","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/assume_unique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert that columns are unique — assume_unique","text":"","code":"df <- data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")) assume_unique(df, id)  # Fails with warning df2 <- data.frame(id = c(1, 1, 2), x = c(\"a\", \"b\", \"c\")) assume_unique(df2, id)"},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind data frames with ID handling — bind_id","title":"Bind data frames with ID handling — bind_id","text":"Binds data frames properly handling ID columns. Checks overlapping IDs, combines data, fills missing IDs.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind data frames with ID handling — bind_id","text":"","code":"bind_id(..., .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind data frames with ID handling — bind_id","text":"... Data frames bind. .id Column name IDs (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind data frames with ID handling — bind_id","text":"Combined data frame valid IDs rows.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bind data frames with ID handling — bind_id","text":"function: Checks IDs overlap datasets (warns ) Binds rows using dplyr::bind_rows() Fills missing IDs using extend_id() Use instead dplyr::bind_rows() working ID columns.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bind data frames with ID handling — bind_id","text":"","code":"df1 <- add_id(data.frame(x = 1:3)) df2 <- data.frame(x = 4:6) combined <- bind_id(df1, df2)"},{"path":"https://gillescolling.com/keyed/reference/bind_keyed.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind rows of keyed data frames — bind_keyed","title":"Bind rows of keyed data frames — bind_keyed","text":"Bind keyed data frames","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_keyed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind rows of keyed data frames — bind_keyed","text":"","code":"bind_keyed(..., .id = NULL)"},{"path":"https://gillescolling.com/keyed/reference/bind_keyed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind rows of keyed data frames — bind_keyed","text":"... Data frames bind. .id Optional column name identify source.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_keyed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind rows of keyed data frames — bind_keyed","text":"keyed data frame key preserved unique, otherwise tibble.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_keyed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bind rows of keyed data frames — bind_keyed","text":"Wrapper dplyr::bind_rows() attempts preserve key metadata.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_rows_keyed.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind rows of keyed data frames — bind_rows_keyed","title":"Bind rows of keyed data frames — bind_rows_keyed","text":"Wrapper dplyr::bind_rows attempts preserve key.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_rows_keyed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind rows of keyed data frames — bind_rows_keyed","text":"","code":"bind_rows_keyed(..., .id = NULL)"},{"path":"https://gillescolling.com/keyed/reference/bind_rows_keyed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind rows of keyed data frames — bind_rows_keyed","text":"... Data frames bind. .id Optional column name identify source.","code":""},{"path":"https://gillescolling.com/keyed/reference/bind_rows_keyed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind rows of keyed data frames — bind_rows_keyed","text":"keyed data frame key preserved unique, otherwise tibble.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_drift.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for drift from committed snapshot — check_drift","title":"Check for drift from committed snapshot — check_drift","text":"Compares current data committed reference snapshot. snapshots keyed key columns, returns cell-level diff. Otherwise falls back structural comparison.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_drift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for drift from committed snapshot — check_drift","text":"","code":"check_drift(.data, reference = NULL)"},{"path":"https://gillescolling.com/keyed/reference/check_drift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for drift from committed snapshot — check_drift","text":".data data frame snapshot reference. reference Optional content hash compare . NULL, uses attached snapshot reference.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_drift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for drift from committed snapshot — check_drift","text":"drift report (class keyed_drift_report), NULL snapshot found.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_drift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for drift from committed snapshot — check_drift","text":"","code":"df <- key(data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")), id) df <- stamp(df)  # Modify the data df$x[1] <- \"modified\" check_drift(df)"},{"path":"https://gillescolling.com/keyed/reference/check_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Check ID integrity — check_id","title":"Check ID integrity — check_id","text":"Validates ID column common issues: missing values, duplicates, suspicious formats.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check ID integrity — check_id","text":"","code":"check_id(.data, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/check_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check ID integrity — check_id","text":".data data frame ID column. .id Column name (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check ID integrity — check_id","text":"Invisibly returns list : valid: TRUE issues found n_na: count NA values n_duplicates: count duplicate IDs format_ok: TRUE IDs look like proper UUIDs/hashes","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check ID integrity — check_id","text":"","code":"df <- add_id(data.frame(x = 1:3)) check_id(df)"},{"path":"https://gillescolling.com/keyed/reference/check_id_disjoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Check IDs are disjoint across datasets — check_id_disjoint","title":"Check IDs are disjoint across datasets — check_id_disjoint","text":"Verifies ID columns overlap datasets. Useful binding datasets ensure ID collisions.","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id_disjoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check IDs are disjoint across datasets — check_id_disjoint","text":"","code":"check_id_disjoint(..., .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/check_id_disjoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check IDs are disjoint across datasets — check_id_disjoint","text":"... Data frames check. .id Column name IDs (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id_disjoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check IDs are disjoint across datasets — check_id_disjoint","text":"Invisibly returns list : disjoint: TRUE overlaps found overlaps: character vector overlapping IDs ()","code":""},{"path":"https://gillescolling.com/keyed/reference/check_id_disjoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check IDs are disjoint across datasets — check_id_disjoint","text":"","code":"df1 <- add_id(data.frame(x = 1:3)) df2 <- add_id(data.frame(x = 4:6)) check_id_disjoint(df1, df2)"},{"path":"https://gillescolling.com/keyed/reference/clear_all_snapshots.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear all snapshots from cache — clear_all_snapshots","title":"Clear all snapshots from cache — clear_all_snapshots","text":"Clear snapshots cache","code":""},{"path":"https://gillescolling.com/keyed/reference/clear_all_snapshots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear all snapshots from cache — clear_all_snapshots","text":"","code":"clear_all_snapshots(confirm = TRUE)"},{"path":"https://gillescolling.com/keyed/reference/clear_all_snapshots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear all snapshots from cache — clear_all_snapshots","text":"confirm TRUE, require confirmation.","code":""},{"path":"https://gillescolling.com/keyed/reference/clear_all_snapshots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear all snapshots from cache — clear_all_snapshots","text":"return value, called side effects.","code":""},{"path":"https://gillescolling.com/keyed/reference/clear_snapshot.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear snapshot for a data frame — clear_snapshot","title":"Clear snapshot for a data frame — clear_snapshot","text":"Removes snapshot reference data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/clear_snapshot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear snapshot for a data frame — clear_snapshot","text":"","code":"clear_snapshot(.data, purge = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/clear_snapshot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear snapshot for a data frame — clear_snapshot","text":".data data frame. purge TRUE, also remove snapshot cache.","code":""},{"path":"https://gillescolling.com/keyed/reference/clear_snapshot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear snapshot for a data frame — clear_snapshot","text":"Data frame without snapshot reference.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare IDs between data frames — compare_ids","title":"Compare IDs between data frames — compare_ids","text":"Compares IDs two data frames detect lost rows.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare IDs between data frames — compare_ids","text":"","code":"compare_ids(before, after, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/compare_ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare IDs between data frames — compare_ids","text":"Data frame transformation. Data frame transformation. .id Column name IDs (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare IDs between data frames — compare_ids","text":"list : lost: IDs present gained: IDs present preserved: IDs present ","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare IDs between data frames — compare_ids","text":"","code":"df1 <- add_id(data.frame(x = 1:5)) df2 <- df1[1:3, ] compare_ids(df1, df2)"},{"path":"https://gillescolling.com/keyed/reference/compare_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare key values between two data frames — compare_keys","title":"Compare key values between two data frames — compare_keys","text":"Identifies keys new, removed, common two keyed data frames. compare values, key membership.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare key values between two data frames — compare_keys","text":"","code":"compare_keys(x, y, by = NULL)"},{"path":"https://gillescolling.com/keyed/reference/compare_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare key values between two data frames — compare_keys","text":"x First keyed data frame. y Second keyed data frame. Column(s) compare. NULL, uses key x.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare key values between two data frames — compare_keys","text":"key comparison object.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_keys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare key values between two data frames — compare_keys","text":"","code":"df1 <- key(data.frame(id = 1:3, x = 1:3), id) df2 <- key(data.frame(id = 2:4, x = 2:4), id) compare_keys(df1, df2)"},{"path":"https://gillescolling.com/keyed/reference/compare_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare structure of two data frames — compare_structure","title":"Compare structure of two data frames — compare_structure","text":"Compares structural properties two data frames without comparing actual values. Useful detecting schema drift.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare structure of two data frames — compare_structure","text":"","code":"compare_structure(x, y)"},{"path":"https://gillescolling.com/keyed/reference/compare_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare structure of two data frames — compare_structure","text":"x First data frame. y Second data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare structure of two data frames — compare_structure","text":"structure comparison object.","code":""},{"path":"https://gillescolling.com/keyed/reference/compare_structure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare structure of two data frames — compare_structure","text":"","code":"df1 <- data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")) df2 <- data.frame(id = 1:5, x = c(\"a\", \"b\", \"c\", \"d\", \"e\"), y = 1:5) compare_structure(df1, df2)"},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnose a join before executing — diagnose_join","title":"Diagnose a join before executing — diagnose_join","text":"Analyzes join cardinality without performing full join. Useful detecting many--many joins explode row count.","code":""},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnose a join before executing — diagnose_join","text":"","code":"diagnose_join(x, y, by = NULL, use_joinspy = TRUE)"},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnose a join before executing — diagnose_join","text":"x Left data frame. y Right data frame. Join specification. use_joinspy TRUE (default), use joinspy enhanced diagnostics available. Set FALSE use built-diagnostics .","code":""},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagnose a join before executing — diagnose_join","text":"list cardinality information, JoinReport object joinspy used.","code":""},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diagnose a join before executing — diagnose_join","text":"joinspy package installed, function delegates joinspy::join_spy() enhanced diagnostics including whitespace detection, encoding issues, detailed match analysis.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/reference/diagnose_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnose a join before executing — diagnose_join","text":"","code":"x <- data.frame(id = c(1, 1, 2), a = 1:3) y <- data.frame(id = c(1, 1, 2), b = 4:6) diagnose_join(x, y, by = \"id\", use_joinspy = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/diff.keyed_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Diff two keyed data frames — diff.keyed_df","title":"Diff two keyed data frames — diff.keyed_df","text":"Compares two data frames row--row using key x align rows. Identifies added, removed, modified rows, cell-level detail modifications.","code":""},{"path":"https://gillescolling.com/keyed/reference/diff.keyed_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diff two keyed data frames — diff.keyed_df","text":"","code":"# S3 method for class 'keyed_df' diff(x, y, ...)"},{"path":"https://gillescolling.com/keyed/reference/diff.keyed_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diff two keyed data frames — diff.keyed_df","text":"x keyed data frame (\"old\" \"reference\" state). y data frame (\"new\" state). Must contain key columns x. ... Ignored (present S3 compatibility base::diff()).","code":""},{"path":"https://gillescolling.com/keyed/reference/diff.keyed_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diff two keyed data frames — diff.keyed_df","text":"keyed_diff object fields: key_cols: character vector key column names n_removed, n_added, n_modified, n_unchanged: counts removed: data frame rows x y added: data frame rows y x changes: named list per-column change tibbles (key columns, old, new) cols_only_x, cols_only_y: columns present one side","code":""},{"path":"https://gillescolling.com/keyed/reference/diff.keyed_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diff two keyed data frames — diff.keyed_df","text":"","code":"old <- key(data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")), id) new <- data.frame(id = 2:4, x = c(\"B\", \"c\", \"d\")) diff(old, new)"},{"path":"https://gillescolling.com/keyed/reference/extend_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend IDs to new rows — extend_id","title":"Extend IDs to new rows — extend_id","text":"Adds IDs rows ID column NA, preserving existing IDs. Useful binding new data existing dataset IDs.","code":""},{"path":"https://gillescolling.com/keyed/reference/extend_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend IDs to new rows — extend_id","text":"","code":"extend_id(.data, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/extend_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend IDs to new rows — extend_id","text":".data data frame ID column (possibly NAs). .id Column name IDs (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/extend_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extend IDs to new rows — extend_id","text":"Data frame IDs filled NA rows.","code":""},{"path":"https://gillescolling.com/keyed/reference/extend_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extend IDs to new rows — extend_id","text":"","code":"# Original data with IDs old <- add_id(data.frame(x = 1:3))  # New data without IDs new <- data.frame(.id = NA_character_, x = 4:5)  # Combine and extend combined <- dplyr::bind_rows(old, new) extend_id(combined)"},{"path":"https://gillescolling.com/keyed/reference/find_duplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Find duplicate keys — find_duplicates","title":"Find duplicate keys — find_duplicates","text":"Identifies rows duplicate key values.","code":""},{"path":"https://gillescolling.com/keyed/reference/find_duplicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find duplicate keys — find_duplicates","text":"","code":"find_duplicates(.data, ...)"},{"path":"https://gillescolling.com/keyed/reference/find_duplicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find duplicate keys — find_duplicates","text":".data data frame. ... Column names check. empty, uses key columns.","code":""},{"path":"https://gillescolling.com/keyed/reference/find_duplicates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find duplicate keys — find_duplicates","text":"Data frame containing rows duplicate keys, .n column showing count.","code":""},{"path":"https://gillescolling.com/keyed/reference/find_duplicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find duplicate keys — find_duplicates","text":"","code":"df <- data.frame(id = c(1, 1, 2, 3, 3, 3), x = letters[1:6]) find_duplicates(df, id)"},{"path":"https://gillescolling.com/keyed/reference/get_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ID column — get_id","title":"Get ID column — get_id","text":"Get ID column","code":""},{"path":"https://gillescolling.com/keyed/reference/get_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ID column — get_id","text":"","code":"get_id(.data, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/get_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ID column — get_id","text":".data data frame. .id Column name (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/get_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ID column — get_id","text":"Character vector IDs, NULL present.","code":""},{"path":"https://gillescolling.com/keyed/reference/get_key_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Get key column names — get_key_cols","title":"Get key column names — get_key_cols","text":"Get key column names","code":""},{"path":"https://gillescolling.com/keyed/reference/get_key_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get key column names — get_key_cols","text":"","code":"get_key_cols(.data)"},{"path":"https://gillescolling.com/keyed/reference/get_key_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get key column names — get_key_cols","text":".data keyed data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/get_key_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get key column names — get_key_cols","text":"Character vector column names, NULL key.","code":""},{"path":"https://gillescolling.com/keyed/reference/has_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if data frame has IDs — has_id","title":"Check if data frame has IDs — has_id","text":"Check data frame IDs","code":""},{"path":"https://gillescolling.com/keyed/reference/has_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if data frame has IDs — has_id","text":"","code":"has_id(.data, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/has_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if data frame has IDs — has_id","text":".data data frame. .id Column name check (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/has_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if data frame has IDs — has_id","text":"Logical.","code":""},{"path":"https://gillescolling.com/keyed/reference/has_key.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if data frame has a key — has_key","title":"Check if data frame has a key — has_key","text":"Check data frame key","code":""},{"path":"https://gillescolling.com/keyed/reference/has_key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if data frame has a key — has_key","text":"","code":"has_key(.data)"},{"path":"https://gillescolling.com/keyed/reference/has_key.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if data frame has a key — has_key","text":".data data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/has_key.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if data frame has a key — has_key","text":"Logical.","code":""},{"path":"https://gillescolling.com/keyed/reference/key.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a key for a data frame — key","title":"Define a key for a data frame — key","text":"Attaches key metadata data frame, marking column(s) form unique identifier rows. Keys validated uniqueness creation.","code":""},{"path":"https://gillescolling.com/keyed/reference/key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a key for a data frame — key","text":"","code":"key(.data, ..., .validate = TRUE, .strict = FALSE)  key(.data) <- value"},{"path":"https://gillescolling.com/keyed/reference/key.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a key for a data frame — key","text":".data data frame tibble. ... Column names (unquoted) form key. Can single column multiple columns composite key. .validate TRUE (default), check key unique. .strict TRUE, error non-unique keys. FALSE (default), warn still attach key. value Character vector column names use key.","code":""},{"path":"https://gillescolling.com/keyed/reference/key.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a key for a data frame — key","text":"keyed data frame (class keyed_df).","code":""},{"path":"https://gillescolling.com/keyed/reference/key.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a key for a data frame — key","text":"","code":"df <- data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")) key(df, id)  # Composite key df2 <- data.frame(country = c(\"US\", \"US\", \"UK\"), year = c(2020, 2021, 2020), val = 1:3) key(df2, country, year)"},{"path":"https://gillescolling.com/keyed/reference/keyed-package.html","id":null,"dir":"Reference","previous_headings":"","what":"keyed: Explicit Key Assumptions for Flat-File Data — keyed-package","title":"keyed: Explicit Key Assumptions for Flat-File Data — keyed-package","text":"Helps make implicit data assumptions explicit attaching keys flat-file data error assumptions violated. Designed CSV-first workflows without database infrastructure version control. Provides key definition, assumption checks, join diagnostics, automatic drift detection via watched data frames snapshot transformation report cell-level changes.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/reference/keyed-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"keyed: Explicit Key Assumptions for Flat-File Data — keyed-package","text":"Maintainer: Gilles Colling gilles.colling051@gmail.com (ORCID) [copyright holder]","code":""},{"path":"https://gillescolling.com/keyed/reference/key_is_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the key is still valid — key_is_valid","title":"Check if the key is still valid — key_is_valid","text":"Checks whether key columns still exist still unique.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_is_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the key is still valid — key_is_valid","text":"","code":"key_is_valid(.data)"},{"path":"https://gillescolling.com/keyed/reference/key_is_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the key is still valid — key_is_valid","text":".data keyed data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_is_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the key is still valid — key_is_valid","text":"Logical. Returns FALSE warning key invalid.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Get key status summary — key_status","title":"Get key status summary — key_status","text":"Returns diagnostic information keyed data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get key status summary — key_status","text":"","code":"key_status(.data)"},{"path":"https://gillescolling.com/keyed/reference/key_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get key status summary — key_status","text":".data data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get key status summary — key_status","text":"key status object diagnostic information.","code":""},{"path":"https://gillescolling.com/keyed/reference/key_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get key status summary — key_status","text":"","code":"df <- key(data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")), id) key_status(df)"},{"path":"https://gillescolling.com/keyed/reference/list_snapshots.html","id":null,"dir":"Reference","previous_headings":"","what":"List all snapshots in cache — list_snapshots","title":"List all snapshots in cache — list_snapshots","text":"List snapshots cache","code":""},{"path":"https://gillescolling.com/keyed/reference/list_snapshots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all snapshots in cache — list_snapshots","text":"","code":"list_snapshots()"},{"path":"https://gillescolling.com/keyed/reference/list_snapshots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all snapshots in cache — list_snapshots","text":"Data frame snapshot information, including size_mb.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that data is complete (no missing values anywhere) — lock_complete","title":"Assert that data is complete (no missing values anywhere) — lock_complete","text":"Checks columns NA values.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that data is complete (no missing values anywhere) — lock_complete","text":"","code":"lock_complete(.data, .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/lock_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that data is complete (no missing values anywhere) — lock_complete","text":".data data frame. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that data is complete (no missing values anywhere) — lock_complete","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert minimum coverage of values — lock_coverage","title":"Assert minimum coverage of values — lock_coverage","text":"Checks fraction non-NA values meets threshold. Useful joins verify expected coverage.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert minimum coverage of values — lock_coverage","text":"","code":"lock_coverage(.data, threshold, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/lock_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert minimum coverage of values — lock_coverage","text":".data data frame. threshold Minimum fraction non-NA values (0 1). ... Column names (unquoted) check. empty, checks columns. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert minimum coverage of values — lock_coverage","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert minimum coverage of values — lock_coverage","text":"","code":"df <- data.frame(id = 1:10, x = c(1:8, NA, NA)) lock_coverage(df, 0.8, x) lock_coverage(df, 0.9, x)  # warns (only 80% coverage)"},{"path":"https://gillescolling.com/keyed/reference/lock_no_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that columns have no missing values — lock_no_na","title":"Assert that columns have no missing values — lock_no_na","text":"Checks specified columns contain NA values.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_no_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that columns have no missing values — lock_no_na","text":"","code":"lock_no_na(.data, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/lock_no_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that columns have no missing values — lock_no_na","text":".data data frame. ... Column names (unquoted) check. empty, checks columns. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_no_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that columns have no missing values — lock_no_na","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_no_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert that columns have no missing values — lock_no_na","text":"","code":"df <- data.frame(id = 1:3, x = c(\"a\", NA, \"c\")) lock_no_na(df, id) lock_no_na(df, x)  # warns"},{"path":"https://gillescolling.com/keyed/reference/lock_nrow.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert row count within expected range — lock_nrow","title":"Assert row count within expected range — lock_nrow","text":"Checks number rows within expected range. Useful sanity checks filtering joins.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_nrow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert row count within expected range — lock_nrow","text":"","code":"lock_nrow(.data, min = 1, max = Inf, expected = NULL, .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/lock_nrow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert row count within expected range — lock_nrow","text":".data data frame. min Minimum expected rows (inclusive). Default 1. max Maximum expected rows (inclusive). Default Inf. expected Exact expected row count. provided, overrides min/max. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_nrow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert row count within expected range — lock_nrow","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_nrow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert row count within expected range — lock_nrow","text":"","code":"df <- data.frame(id = 1:100) lock_nrow(df, min = 50, max = 200) lock_nrow(df, expected = 100)"},{"path":"https://gillescolling.com/keyed/reference/lock_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert that columns are unique — lock_unique","title":"Assert that columns are unique — lock_unique","text":"Checks combination specified columns unique values. point--time assertion either passes silently fails.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert that columns are unique — lock_unique","text":"","code":"lock_unique(.data, ..., .strict = FALSE)"},{"path":"https://gillescolling.com/keyed/reference/lock_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert that columns are unique — lock_unique","text":".data data frame. ... Column names (unquoted) check uniqueness. .strict TRUE, error failure. FALSE (default), warn.","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert that columns are unique — lock_unique","text":"Invisibly returns .data (piping).","code":""},{"path":"https://gillescolling.com/keyed/reference/lock_unique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assert that columns are unique — lock_unique","text":"","code":"df <- data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")) lock_unique(df, id)  # Fails with warning df2 <- data.frame(id = c(1, 1, 2), x = c(\"a\", \"b\", \"c\")) lock_unique(df2, id)"},{"path":"https://gillescolling.com/keyed/reference/make_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ID from columns — make_id","title":"Create ID from columns — make_id","text":"Creates ID column combining values one columns. Unlike add_id(), produces deterministic IDs based column values.","code":""},{"path":"https://gillescolling.com/keyed/reference/make_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ID from columns — make_id","text":"","code":"make_id(.data, ..., .id = \".id\", .sep = \"|\")"},{"path":"https://gillescolling.com/keyed/reference/make_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ID from columns — make_id","text":".data data frame. ... Columns combine ID. .id Column name ID (default: \".id\"). .sep Separator column values (default: \"|\").","code":""},{"path":"https://gillescolling.com/keyed/reference/make_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ID from columns — make_id","text":"Data frame ID column added.","code":""},{"path":"https://gillescolling.com/keyed/reference/make_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ID from columns — make_id","text":"","code":"df <- data.frame(country = c(\"US\", \"UK\", \"US\"), year = c(2020, 2020, 2021)) make_id(df, country, year) #>   .id       country year #> 1 US|2020  US      2020 #> 2 UK|2020  UK      2020 #> 3 US|2021  US      2021"},{"path":"https://gillescolling.com/keyed/reference/remove_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove ID column — remove_id","title":"Remove ID column — remove_id","text":"Remove ID column","code":""},{"path":"https://gillescolling.com/keyed/reference/remove_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove ID column — remove_id","text":"","code":"remove_id(.data, .id = \".id\")"},{"path":"https://gillescolling.com/keyed/reference/remove_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove ID column — remove_id","text":".data data frame. .id Column name remove (default: \".id\").","code":""},{"path":"https://gillescolling.com/keyed/reference/remove_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove ID column — remove_id","text":"Data frame without ID column.","code":""},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":null,"dir":"Reference","previous_headings":"","what":"Stamp a data frame as reference — stamp","title":"Stamp a data frame as reference — stamp","text":"Stores snapshot current data state, including full data frame. enables cell-level drift reports used check_drift().","code":""},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stamp a data frame as reference — stamp","text":"","code":"stamp(.data, name = NULL, .silent = FALSE)  commit_keyed(.data, name = NULL)"},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stamp a data frame as reference — stamp","text":".data data frame (preferably keyed). name Optional name snapshot. NULL, derived data. .silent TRUE, suppress cli output. Used internally auto-stamping watch()ed data frames.","code":""},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stamp a data frame as reference — stamp","text":"Invisibly returns .data snapshot metadata attached.","code":""},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stamp a data frame as reference — stamp","text":"Snapshots stored memory session. keyed content hash, identical data shares snapshot. data watch()ed, dplyr verbs auto-stamp executing, creating automatic safety net drift detection.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/reference/stamp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stamp a data frame as reference — stamp","text":"","code":"df <- key(data.frame(id = 1:3, x = c(\"a\", \"b\", \"c\")), id) df <- stamp(df)  # Later, check for drift df2 <- df df2$x[1] <- \"z\" check_drift(df2)"},{"path":"https://gillescolling.com/keyed/reference/summary.keyed_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for keyed data frames — summary.keyed_df","title":"Summary method for keyed data frames — summary.keyed_df","text":"Summary method keyed data frames","code":""},{"path":"https://gillescolling.com/keyed/reference/summary.keyed_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for keyed data frames — summary.keyed_df","text":"","code":"# S3 method for class 'keyed_df' summary(object, ...)"},{"path":"https://gillescolling.com/keyed/reference/summary.keyed_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for keyed data frames — summary.keyed_df","text":"object keyed data frame. ... Additional arguments (ignored).","code":""},{"path":"https://gillescolling.com/keyed/reference/summary.keyed_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for keyed data frames — summary.keyed_df","text":"Invisibly returns summary list.","code":""},{"path":"https://gillescolling.com/keyed/reference/unkey.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove key from a data frame — unkey","title":"Remove key from a data frame — unkey","text":"Remove key data frame","code":""},{"path":"https://gillescolling.com/keyed/reference/unkey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove key from a data frame — unkey","text":"","code":"unkey(.data)"},{"path":"https://gillescolling.com/keyed/reference/unkey.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove key from a data frame — unkey","text":".data keyed data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/unkey.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove key from a data frame — unkey","text":"tibble without key metadata.","code":""},{"path":"https://gillescolling.com/keyed/reference/unwatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop watching a keyed data frame — unwatch","title":"Stop watching a keyed data frame — unwatch","text":"Removes watched attribute. Dplyr verbs longer auto-stamp.","code":""},{"path":"https://gillescolling.com/keyed/reference/unwatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop watching a keyed data frame — unwatch","text":"","code":"unwatch(.data)"},{"path":"https://gillescolling.com/keyed/reference/unwatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stop watching a keyed data frame — unwatch","text":".data data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/unwatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stop watching a keyed data frame — unwatch","text":".data without watched attribute.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/reference/unwatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stop watching a keyed data frame — unwatch","text":"","code":"df <- key(data.frame(id = 1:3, x = 1:3), id) |> watch() df <- unwatch(df)"},{"path":"https://gillescolling.com/keyed/reference/watch.html","id":null,"dir":"Reference","previous_headings":"","what":"Watch a keyed data frame for automatic drift detection — watch","title":"Watch a keyed data frame for automatic drift detection — watch","text":"Marks keyed data frame \"watched\". Watched data frames automatically stamped dplyr verb, check_drift() always reports changes recent transformation step.","code":""},{"path":"https://gillescolling.com/keyed/reference/watch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Watch a keyed data frame for automatic drift detection — watch","text":"","code":"watch(.data)"},{"path":"https://gillescolling.com/keyed/reference/watch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Watch a keyed data frame for automatic drift detection — watch","text":".data keyed data frame.","code":""},{"path":"https://gillescolling.com/keyed/reference/watch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Watch a keyed data frame for automatic drift detection — watch","text":"Invisibly returns .data watched attribute set baseline snapshot committed.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/reference/watch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Watch a keyed data frame for automatic drift detection — watch","text":"","code":"df <- key(data.frame(id = 1:5, x = letters[1:5]), id) |> watch() df2 <- df |> dplyr::filter(id > 2) check_drift(df2)"},{"path":[]},{"path":"https://gillescolling.com/keyed/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"keyed 0.2.0","text":"stamp() replaces commit_keyed() snapshot creation. commit_keyed() deprecated lifecycle warning. diff() method keyed data frames: cell-level comparison using key columns align rows. Reports added, removed, modified rows per-column change detail. watch() / unwatch(): Mark keyed data frames “watched” dplyr verbs auto-stamp executing. Turns drift detection manual ceremony automatic safety net. check_drift() now returns cell-level reports. snapshot current data keyed key columns, drift report includes full keyed_diff per-column change detail. Falls back structural comparison (row count, columns) keys differ lost. stamp() gains .silent parameter suppressing cli output auto-stamping. list_snapshots() gains size_mb column showing memory usage per snapshot. compare_structure(), compare_keys(): structural comparison helpers.","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"keyed 0.2.0","text":"Renamed commit_keyed() stamp(). old name soft-deprecated.","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"internal-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Internal Changes","title":"keyed 0.2.0","text":"Snapshot cache now stores full data frames (just hashes), enabling cell-level drift comparison without re-reading source data. Cache reduced 100 20 entries adds 100 MB soft memory cap. Eviction remains LRU-based now considers count memory. dplyr methods (filter, mutate, select, arrange, rename, summarise, slice, distinct, group_by, ungroup) now propagate snapshot references watched state transformations.","code":""},{"path":[]},{"path":"https://gillescolling.com/keyed/news/index.html","id":"breaking-changes-0-1-1","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"keyed 0.1.1","text":"Operations break key uniqueness now error instead warning. Previously, keyed warn silently remove key. Now stops error, requiring explicit unkey() proceed. prevents silent data corruption.","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"improvements-0-1-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"keyed 0.1.1","text":"Added Codecov integration test coverage tracking Improved README problem-solution framing Row UUIDs section Added CONTRIBUTING.md contribution guidelines Expanded test suite 90%+ coverage Fixed find_duplicates() work keyed data duplicates","code":""},{"path":[]},{"path":[]},{"path":"https://gillescolling.com/keyed/news/index.html","id":"key-definition-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Key Definition","title":"keyed 0.1.0","text":"key() / unkey(): Define remove keys data frames has_key() / get_key_cols() / key_is_valid(): Query key status Keys survive dplyr transformations (filter, mutate, arrange, etc.)","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"assumption-checks-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Assumption Checks","title":"keyed 0.1.0","text":"lock_unique(): Verify column uniqueness lock_no_na(): Check missing values lock_complete(): Ensure expected values present lock_coverage(): Validate reference coverage lock_nrow(): Check row count bounds","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"join-diagnostics-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Join Diagnostics","title":"keyed 0.1.0","text":"diagnose_join(): Analyze join cardinality executing Optional integration joinspy enhanced diagnostics","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"row-identity-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Row Identity","title":"keyed 0.1.0","text":"add_id() / remove_id(): Add/remove stable UUIDs has_id() / get_id(): Query ID status extend_id(): Fill missing IDs binding make_id(): Create composite IDs columns bind_id(): Combine data ID handling check_id() / check_id_disjoint(): Validate ID integrity compare_ids(): Detect lost/gained rows","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"drift-detection-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Drift Detection","title":"keyed 0.1.0","text":"commit_keyed(): Commit reference snapshot check_drift(): Detect changes snapshot list_snapshots() / clear_snapshot() / clear_all_snapshots(): Manage snapshots","code":""},{"path":"https://gillescolling.com/keyed/news/index.html","id":"diagnostics-0-1-0","dir":"Changelog","previous_headings":"Initial Release","what":"Diagnostics","title":"keyed 0.1.0","text":"key_status(): Quick status summary summary.keyed_df(): Detailed summary method compare_structure(): Compare schema data frames compare_keys(): Compare key values datasets find_duplicates(): Locate duplicate key values","code":""}]
